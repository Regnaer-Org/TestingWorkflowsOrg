name: Daily Agile Snapshot CSV

on:
  workflow_dispatch:
  schedule:
    # 5:00 PM Central = 22:00 UTC
    - cron: '0 22 * * *'

permissions:
  contents: write
  id-token: write

jobs:
  fetch-issues:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4

      - name: Set up Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20.x'

      - name: Set snapshot filename (Central Time, YYYY.MM.DD)
        id: setvars
        run: |
          SNAPSHOT_DATE=$(TZ='America/Chicago' date +'%Y.%m.%d')
          echo "SNAPSHOT_DATE=$SNAPSHOT_DATE" >> $GITHUB_ENV
          echo "SNAPSHOT_FILENAME=project.issues_${SNAPSHOT_DATE}.csv" >> $GITHUB_ENV

      # -------------------------------------------------------------
      # INSTRUCTIONS FOR MAINTAINERS:
      #
      # To ADD a new ProjectV2 field (e.g. "Risk") as a CSV column and metadata:
      #   1. Add the field name to the FIELDS variable (e.g. FIELDS="Sprint Team Priority Status Risk")
      #   2. Add the field name to the jq --argjson fields array (e.g. --argjson fields '["Sprint","Team","Priority","Status","Risk"]')
      #   3. That's it! The workflow will create a new column (e.g. "risk") in your CSV, and a metadata CSV.
      #
      # To REMOVE a ProjectV2 field:
      #   1. Remove the field name from both the FIELDS variable and the jq --argjson fields array above.
      #
      # Field names are case-sensitive and must match exactly as they appear in GitHub Projects.
      # The CSV column header will be the field name, lowercased.
      #
      # If you want to extract ALL custom fields automatically, ask an admin to update this workflow for dynamic field extraction.
      # -------------------------------------------------------------

      - name: Fetch Issues (with correct ProjectV2 field fragments)
        id: fetch_issues
        run: |
          set -ex
          echo 'Fetching issues from the project...'
          PROJECT_ID="PVT_kwDODH0FwM4A3yi4"
          AFTER_CURSOR=null
          HAS_NEXT_PAGE=true
          OUTPUT_FILE="project-issues.json"
          echo "[]" > $OUTPUT_FILE
          while [ "$HAS_NEXT_PAGE" = "true" ]; do
            QUERY=$(cat <<EOF
            query GetProjectV2Items(\$afterCursor: String) {
              node(id: "$PROJECT_ID") {
                ... on ProjectV2 {
                  id
                  title
                  number
                  items(first: 100, after: \$afterCursor) {
                    nodes {
                      id
                      fieldValues(first: 100) {
                        nodes {
                          ... on ProjectV2ItemFieldTextValue {
                            text
                            field { ... on ProjectV2FieldCommon { name } }
                          }
                          ... on ProjectV2ItemFieldDateValue {
                            date
                            field { ... on ProjectV2FieldCommon { name } }
                          }
                          ... on ProjectV2ItemFieldNumberValue {
                            number
                            field { ... on ProjectV2FieldCommon { name } }
                          }
                          ... on ProjectV2ItemFieldSingleSelectValue {
                            name
                            field { ... on ProjectV2SingleSelectField { name options { id name description color } } }
                          }
                          ... on ProjectV2ItemFieldIterationValue {
                            title
                            field { 
                              ... on ProjectV2IterationField {
                                name
                                configuration {
                                  iterations {
                                    id title startDate duration endDate
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                      content {
                        ... on Issue {
                          id
                          number
                          title
                          state
                          createdAt
                          updatedAt
                          url
                          author { login }
                          closedAt
                          milestone { title number state }
                          issueType { name }
                          labels(first: 100) { nodes { name color } }
                          assignees(first: 100) { nodes { login } }
                          parent {
                            ... on Issue { title number url id issueType { name } }
                          }
                          repository { nameWithOwner }
                        }
                      }
                    }
                    pageInfo {
                      endCursor
                      hasNextPage
                    }
                  }
                  # Fetch project-level field metadata for separate tables
                  fields(first: 50) {
                    nodes {
                      ... on ProjectV2FieldCommon {
                        id
                        name
                        dataType
                        createdAt
                        updatedAt
                        settings
                      }
                      ... on ProjectV2SingleSelectField {
                        id
                        name
                        dataType
                        createdAt
                        updatedAt
                        options { id name description color }
                      }
                      ... on ProjectV2IterationField {
                        id
                        name
                        dataType
                        createdAt
                        updatedAt
                        configuration {
                          iterations {
                            id
                            title
                            startDate
                            duration
                            endDate
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          EOF
            )
            PAYLOAD=$(jq -n --arg query "$QUERY" --argjson vars "{\"afterCursor\":$AFTER_CURSOR}" '{query: $query, variables: $vars}')
            RESPONSE=$(curl -s -w "%{http_code}" \
              -H "Authorization: Bearer ${{ secrets.MILESTONE_SYNC }}" \
              -H "Content-Type: application/json" \
              -d "$PAYLOAD" \
              https://api.github.com/graphql)
            HTTP_STATUS="${RESPONSE: -3}"
            RESPONSE_BODY="${RESPONSE::-3}"
            echo "HTTP Status: $HTTP_STATUS"
            if [ "$HTTP_STATUS" -ne 200 ]; then
              echo "Error: Failed to fetch project issues. HTTP Status: $HTTP_STATUS"
              echo "Response: $RESPONSE_BODY"
              exit 1
            fi
            # Only update OUTPUT_FILE on the first page, otherwise append nodes
            if [ "$AFTER_CURSOR" = null ]; then
              # Overwrite with first page
              echo "$RESPONSE_BODY" | jq '.data.node' > project-metadata.json
              echo "$RESPONSE_BODY" | jq '.data.node.items.nodes' > $OUTPUT_FILE
            else
              # Append subsequent pages
              ITEMS=$(echo "$RESPONSE_BODY" | jq '.data.node.items.nodes')
              jq -c --argjson newItems "$ITEMS" '. + $newItems' $OUTPUT_FILE > temp.json && mv temp.json $OUTPUT_FILE
            fi
            END_CURSOR=$(echo "$RESPONSE_BODY" | jq -r '.data.node.items.pageInfo.endCursor')
            HAS_NEXT_PAGE=$(echo "$RESPONSE_BODY" | jq -r '.data.node.items.pageInfo.hasNextPage')
            AFTER_CURSOR="\"$END_CURSOR\""
          done
          echo "All project issues fetched successfully! Saved to $OUTPUT_FILE and project-metadata.json."

      - name: Convert JSON to CSV (main issue table with sprint metadata columns)
        run: |
          echo "Converting JSON to CSV with sprint metadata columns..."
          FIELDS="Sprint Team Priority Status"
          HEADER='id,content_id,number,title,state,createdAt,updatedAt,url,author,closedAt,milestone_title,milestone_number,milestone_state,issueType,labels,assignees,parent_title,parent_number,parent_url,parent_id,parent_issueType,repository'
          # Sprint metadata columns
          HEADER="$HEADER,sprint_title,sprint_start,sprint_end,sprint_duration"
          # Remaining projectv2 fields as columns (not their metadata)
          for FIELD in $FIELDS; do
            HEADER="$HEADER,${FIELD,,}"
          done
          echo "$HEADER" > project-issues.csv

          jq_filter=$(cat <<'EOF'
            .[] as $item |
            ( [$item.fieldValues.nodes[]? | select(.field and .field.name)]
                | group_by(.field.name)
                | map({ (.[0].field.name): [ .[] | (.name // .title // .text // .date // .number // "" ) ] })
                | add // {}
            ) as $fields_map
            |
            ($fields_map.Sprint // [""]) as $sprint_titles
            |
            [
              $item.id,
              $item.content.id,
              $item.content.number,
              $item.content.title,
              $item.content.state,
              $item.content.createdAt,
              $item.content.updatedAt,
              $item.content.url,
              $item.content.author.login,
              $item.content.closedAt,
              ($item.content.milestone.title // ""),
              ($item.content.milestone.number // ""),
              ($item.content.milestone.state // ""),
              ($item.content.issueType.name // ""),
              ([ $item.content.labels.nodes[].name ] | join(";")),
              ([ $item.content.assignees.nodes[].login ] | join(";")),
              ($item.content.parent.title // ""),
              ($item.content.parent.number // ""),
              ($item.content.parent.url // ""),
              ($item.content.parent.id // ""),
              ($item.content.parent.issueType.name // ""),
              $item.content.repository.nameWithOwner,
              # Sprint metadata columns (filled below)
              ($sprint_titles[0] // ""), "", "", "",
              ($fields_map.Team // [""] | join(";")),
              ($fields_map.Priority // [""] | join(";")),
              ($fields_map.Status // [""] | join(";"))
            ]
            | @csv
          EOF
          )

          jq -r "$jq_filter" project-issues.json >> project-issues.csv
          echo "Main CSV conversion (with sprint metadata columns placeholder) completed."

      - name: Insert Sprint Metadata into Main Table (post-process)
        run: |
          mkdir -p agilereporting
          mkdir -p agilereportingmetadata

          # Extract all Sprint metadata from project-metadata.json (iterations in Sprint field)
          jq -r '
            .fields.nodes[]
            | select(.name == "Sprint" and .configuration.iterations)
            | .configuration.iterations[]
            | [.title, .startDate, .endDate, .duration]
            | @csv
          ' project-metadata.json > agilereportingmetadata/Sprint.csv

          # Build a Sprint metadata map for use in jq
          jq -r '
            .fields.nodes[]
            | select(.name == "Sprint" and .configuration.iterations)
            | .configuration.iterations[]
            | { (.title): {start: .startDate, end: .endDate, duration: .duration} }
          ' project-metadata.json | jq -s add > sprintmap.json

          # Fill in the main CSV with sprint metadata
          python3 - <<EOF
          import os
          import csv
          import json
          
          with open("project-issues.csv", newline="", encoding="utf-8") as f:
              rows = list(csv.reader(f))
          
          with open("sprintmap.json", encoding="utf-8") as f:
              sprintmap = json.load(f)
          
          header = rows[0]
          outrows = [header]
          for row in rows[1:]:
              sprint = row[22]
              sprintmeta = sprintmap.get(sprint, {}) if sprint else {}
              # sprint_title,sprint_start,sprint_end,sprint_duration are columns 23,24,25,26 (0-based: 22,23,24,25)
              row[23] = sprintmeta.get("start", "")
              row[24] = sprintmeta.get("end", "")
              row[25] = str(sprintmeta.get("duration", "")) if sprintmeta.get("duration") is not None else ""
              outrows.append(row)
          with open(f"agilereporting/{os.environ['SNAPSHOT_FILENAME']}", "w", newline="", encoding="utf-8") as f:
              csv.writer(f).writerows(outrows)
          EOF

          rm sprintmap.json
          echo "Sprint metadata inserted and main CSV moved to agilereporting/."

      - name: Create/overwrite metadata tables for each field
        run: |
          mkdir -p agilereportingmetadata
          # For each ProjectV2 field, write out a CSV of all possible values/metadata
          jq -r '
            .fields.nodes[]
            | select(.name == "Sprint" and .configuration.iterations)
            | .configuration.iterations[]
            | [.id, .title, .startDate, .endDate, .duration]
            | @csv
          ' project-metadata.json > agilereportingmetadata/Sprint.csv

          jq -r '
            .fields.nodes[]
            | select(.name == "Team" and .options)
            | .options[]
            | [.id, .name, .description, .color]
            | @csv
          ' project-metadata.json > agilereportingmetadata/Team.csv

          jq -r '
            .fields.nodes[]
            | select(.name == "Priority" and .options)
            | .options[]
            | [.id, .name, .description, .color]
            | @csv
          ' project-metadata.json > agilereportingmetadata/Priority.csv

          jq -r '
            .fields.nodes[]
            | select(.name == "Status" and .options)
            | .options[]
            | [.id, .name, .description, .color]
            | @csv
          ' project-metadata.json > agilereportingmetadata/Status.csv

      - name: Commit and push snapshot and metadata to repo
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git add agilereporting/project.issues_${SNAPSHOT_DATE}.csv
          git add agilereportingmetadata/Sprint.csv
          git add agilereportingmetadata/Team.csv
          git add agilereportingmetadata/Priority.csv
          git add agilereportingmetadata/Status.csv
          git commit -m "Agile snapshot and metadata for $SNAPSHOT_DATE" || echo "Nothing to commit"
          git push
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
